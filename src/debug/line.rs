//! TODO talk a bit about what this is useful for
//! mention that it is .debug_line
use crate::{
    elf::{Offset, RelativeAddr, Stream},
    utils::{self, KeyMap, key16},
};
use rangemap::RangeMap;
use std::{collections::HashMap, error::Error};

key16!(FilesKey);

// TODO may want a RelativeAddress type here, these can probably be 32 bits

/// Used to associate relative addresses to line numbers within a source file.
pub struct LineInfo {
    /// The source files used to build the exe or lib.
    pub units: Vec<CompilationUnit>,

    /// Paths to source files with dir prepended. These are typically either absolute
    /// paths or paths relative to the working directory used to build the exe or lib.
    pub files: KeyMap<FilesKey, String>,

    /// Used to map relative addresses to source file + line number + column number.
    pub lines: RangeMap<RelativeAddr, LineValue>,
}

/// LineInfo will map relative addresses to one of these.
#[derive(Clone, Copy, Eq, PartialEq)]
pub struct LineValue {
    // TODO there will often be a *lot* of these so we want to keep these as small as
    // possible. Not clear we can make file much smaller because a large project will
    // have a ton of source files, especially counting includes. Similarly large files
    // will have a lot of lines, especially machine generated files. OTOH column can
    // certainly be smaller. So maybe we can use something like bitvec to do a bit-field
    // sort of thing. Or maybe a manual bit-field of line/column. Could use four bits for
    // column with 0 being unknown/it was too large.
    pub file: FilesKey, // index into LineInfo.files
    pub line: u32,      // 1-based, found a file at work with 35K lines
    pub column: u16,    // 1-based
}

pub struct CompilationUnit {
    /// paths that were searched for includes
    pub include_paths: Vec<String>,

    /// files compiled into this compilation unit, for C/C++ this will have a .c file and
    /// then any included header files
    pub source_files: Vec<SourceFile>,
}

/// Path to a source file or header (for C/C++).
#[derive(Clone)]
pub struct SourceFile {
    /// full or relative path to a source file
    pub file: String,

    /// used for relative paths, will be "." or a dir from include_paths
    pub dir: String,

    /// length of the file (may not be available)
    pub length: Option<u32>,
}

struct RawLineInfo {
    /// size in bytes of the smallest target machine instruction
    min_instruction_len: u8,

    /// maximum number of individual operations that may be encoded in an instruction
    max_ops_per_instruction: u8,

    /// initial value of the is_stmt register
    default_is_stmt: u8,

    /// affects the meaning of the special opcodes
    line_base: i8,

    /// affects the meaning of the special opcodes
    line_range: u8,

    /// number assigned to the first special opcode
    opcode_base: u8,

    /// paths that were searched for included source files in this compilation unit
    include_paths: Vec<String>, // TODO this and below should be in a different struct?

    /// source files, for C/C++ this will have a .c file and then header files
    source_files: Vec<SourceFile>,

    /// these are used to map relative addresses to source file + line number + column number
    opcodes: Vec<Opcode>,
}

// TODO may want to use interval crate to store the end result
struct StateMachine {
    /// program-counter value corresponding to a machine instruction generated by the compiler
    address: RelativeAddr,

    /// the index of an operation within a VLIW instruction, 0 for x86
    op_index: u32,

    /// the identity of the source file corresponding to a machine instruction
    file: String,

    /// 1-based line number, 0 if unknown
    line: u32,

    /// 1-based column number, 0 for "left edge"
    column: u32,

    /// true if the current instruction is a recommended breakpoint location
    is_stmt: bool,

    /// indicates that the current instruction is the beginning of a basic block
    basic_block: bool,

    /// terminates a sequence of lines
    end_sequence: bool,

    /// indicates that the current address is one (of possibly many) where execution
    /// should be suspended for an entry breakpoint of a function
    prologue_end: bool,

    /// indicating that the current address is one (of possibly many) where execution
    /// should be suspended for an exit breakpoint of a function
    prologue_begin: bool,

    /// encodes the applicable instruction set architecture for the current instruction
    isa: u32,

    /// the block to which the current instruction belongs
    discriminator: u32,
}

#[derive(Clone, Debug, Hash, PartialEq, Eq)] // 6.2.5.2 and 7.22, TODO do we need all these traits?
enum Opcode {
    /// Standard opcodes
    Copy,
    AdvancePc(u32),
    AdvanceLine(u32),
    SetFile(u32),
    SetColumn(u32),
    NegateStmt,
    SetBasicBlock,
    ConstAddPc,
    FixedAdvancePc(u16),
    SetPrologueEnd,
    SetEpilogueBegin,
    SetIsa(u32),

    /// Extended opcodes
    EndSequence,
    SetAddress(RelativeAddr),
    DefineFile(String, u32, u32, u32),
    SetDiscriminator(u32),

    /// Special opcodes
    Special(u8),
    Vendor(u8),
}

impl LineInfo {
    pub fn new(stream: &mut Stream, max_offset: Offset) -> Self {
        let mut infos = LineInfo::parse_raw_infos(stream, max_offset);
        let mut files = KeyMap::new("?".to_string());
        let units = LineInfo::get_units(&mut infos);
        let lines = LineInfo::find_lines(&infos, &mut files);
        LineInfo {
            files,
            units,
            lines,
        }
    }

    fn parse_raw_infos(stream: &mut Stream, max_offset: Offset) -> Vec<RawLineInfo> {
        let mut infos = Vec::new();
        while stream.offset < max_offset {
            match RawLineInfo::new(stream) {
                Ok(info) => infos.push(info),
                Err(err) => {
                    utils::warn(&format!("failed to read line info: {err}"));
                    break;
                }
            }
        }
        infos
    }

    fn get_units(infos: &mut [RawLineInfo]) -> Vec<CompilationUnit> {
        let mut units = Vec::new();
        for info in infos.iter_mut() {
            let include_paths = std::mem::take(&mut info.include_paths);
            let source_files = info.source_files.clone(); // TODO it's a little tricky to take this once because run() needs it in place
            units.push(CompilationUnit {
                include_paths,
                source_files,
            });
        }
        units
    }

    fn find_lines(
        infos: &[RawLineInfo],
        files: &mut KeyMap<FilesKey, String>,
    ) -> RangeMap<RelativeAddr, LineValue> {
        let mut lines = Vec::new();
        for info in infos.iter() {
            let mut sm = StateMachine::new(info);
            sm.run(info, files, &mut lines);
        }

        let mut map: RangeMap<RelativeAddr, LineValue> = RangeMap::new();
        if !lines.is_empty() {
            let (mut addr, mut info) = lines[0];
            for (next_addr, next_info) in lines.iter().skip(1) {
                map.insert(addr..(*next_addr), info);
                addr = *next_addr;
                info = *next_info;
            }
            map.insert(addr..(addr + 1), info);
        }
        map
    }
}

impl RawLineInfo {
    fn new(stream: &mut Stream) -> Result<Self, Box<dyn Error>> {
        let _start = stream.offset; // 6.2.4
        let len = stream.read_word()? as usize;
        let _length = if len == 0xffffffff {
            stream.read_xword()? as usize
        } else {
            len
        };
        let version = stream.read_half()?;
        if !(version == 2 || version == 3) {
            return Err(format!("unsupported dwarf version: {version}").into());
        }
        let (_address_size, _segment_selector_size) = if version >= 5 {
            (Some(stream.read_byte()?), Some(stream.read_byte()?))
        } else {
            (None, None)
        };
        let _header_length = if version >= 5 {
            stream.read_xword()? as usize
        } else {
            stream.read_word()? as usize
        };
        let min_instruction_len = stream.read_byte()?;
        let max_ops_per_instruction = if version >= 4 { stream.read_byte()? } else { 1 };
        let default_is_stmt = stream.read_byte()?;
        let line_base = stream.read_sbyte()?;
        let line_range = stream.read_byte()?;
        let opcode_base = stream.read_byte()?;

        let mut opcode_sizes = HashMap::new();
        for i in 1..opcode_base {
            let size = stream.read_byte()? as u32;
            opcode_sizes.insert(i + 1, size);
        }

        // TODO the rest of this is quite different in version 5
        let mut include_paths = Vec::new();
        loop {
            let s = stream.read_string()?;
            if s.is_empty() {
                break;
            }
            include_paths.push(s);
        }

        let mut source_files = Vec::new();
        loop {
            let file = stream.read_string()?;
            if file.is_empty() {
                break;
            }
            let index = decode_u32(stream)?;
            let dir = if index == 0 {
                ".".to_string()
            } else if (index as usize) <= include_paths.len() {
                include_paths[(index as usize) - 1].clone()
            } else {
                format!("bad dir index {index}")
            };
            let _last_mod = decode_u32(stream)?;
            let len = decode_u32(stream)?;
            let length = if len == 0 { None } else { Some(len) };
            source_files.push(SourceFile { file, dir, length });
        }
        // println!("offset: 0x{:x}", stream.offset.0 - start.0);

        // This isn't documented very well, but opcodes follow the header. And after the
        // opcodes more headers/opcodes will follow for the remaining source files.
        let mut opcodes = Vec::new();
        loop {
            let opcode = Opcode::from_steam(stream, opcode_base)?;
            let done = opcode == Opcode::EndSequence;
            opcodes.push(opcode);
            if done {
                break;
            }
        }

        Ok(RawLineInfo {
            min_instruction_len,
            max_ops_per_instruction,
            default_is_stmt,
            line_base,
            line_range,
            opcode_base,
            include_paths,
            source_files,
            opcodes,
        })
    }

    fn default_path(&self) -> String {
        if self.source_files.is_empty() {
            "?".to_string()
        } else {
            format!("{}/{}", self.source_files[0].dir, self.source_files[0].file)
        }
    }
}

impl StateMachine {
    fn new(info: &RawLineInfo) -> Self {
        StateMachine {
            address: RelativeAddr(0),
            op_index: 0,
            file: info.default_path(),
            line: 1,
            column: 0,
            is_stmt: info.default_is_stmt != 0,
            basic_block: false,
            end_sequence: false,
            prologue_end: false,
            prologue_begin: false,
            isa: 0,
            discriminator: 0,
        }
    }

    /// Addresses will always increase. Line numbers may decrease due to optimizations
    /// like inlining.
    fn run(
        &mut self,
        info: &RawLineInfo,
        files: &mut KeyMap<FilesKey, String>,
        lines: &mut Vec<(RelativeAddr, LineValue)>,
    ) {
        // 6.2.5
        for opcode in info.opcodes.iter() {
            // print!("{opcode:?}  ");
            match opcode {
                Opcode::AdvanceLine(advance) => {
                    self.line = ((self.line as i64) + (*advance as i64)) as u32;
                    // println!("line: {} +line: {}", self.line, *advance);
                }
                Opcode::AdvancePc(advance) => {
                    let addr_incr = (info.min_instruction_len as u32)
                        * ((self.op_index + advance) / (info.max_ops_per_instruction as u32));
                    self.address += addr_incr as u64;
                    self.op_index =
                        (self.op_index + advance) % (info.max_ops_per_instruction as u32);
                    // println!("addr: {:x} +addr: {}", self.address, addr_incr);
                }
                Opcode::ConstAddPc => {
                    let adjust = 255 - info.opcode_base;
                    let advance = (adjust / info.line_range) as u32;
                    let addr_incr = (info.min_instruction_len as u32)
                        * ((self.op_index + advance) / (info.max_ops_per_instruction as u32));
                    self.address += addr_incr as u64;
                    self.op_index =
                        (self.op_index + advance) % (info.max_ops_per_instruction as u32);
                    // println!("addr: {:x} +addr: {}", self.address, addr_incr);
                }
                Opcode::Copy => {
                    // TODO record a row in the matrix
                    self.discriminator = 0;
                    self.basic_block = false;
                    self.prologue_end = false;
                    self.prologue_begin = false;
                    self.record_line(files, lines);
                    // println!(
                    //     "{opcode:?} {:x} at {}:{}",
                    //     self.address, self.line, self.column
                    // );
                }
                Opcode::DefineFile(file, dir, _last_mod, _length) => {
                    // I think this would be used for things like cross compilation unit
                    // inlining.
                    let dir = if *dir == 0 {
                        ".".to_string()
                    } else if (*dir as usize) <= info.include_paths.len() {
                        info.include_paths[(*dir as usize) - 1].clone()
                    } else {
                        format!("bad dir index {dir}")
                    };
                    self.file = format!("{}/{}", dir, file);
                    // println!("new file: {}", _file);
                }
                Opcode::EndSequence => {
                    // println!(
                    //     "{opcode:?} {:x} at {}:{}",
                    //     self.address, self.line, self.column
                    // );
                    self.record_line(files, lines);
                    self.end_sequence = true;
                    self.address = RelativeAddr(0);
                    self.op_index = 0;
                    self.file = info.default_path();
                    self.line = 1;
                    self.column = 0;
                    self.is_stmt = info.default_is_stmt != 0;
                    self.basic_block = false;
                    self.prologue_end = false;
                    self.prologue_begin = false;
                    self.isa = 0;
                    self.discriminator = 0;
                    // println!();
                }
                Opcode::FixedAdvancePc(delta) => {
                    self.address += *delta as u64;
                    // println!("addr: {:x} +addr: {}", self.address, delta);
                }
                Opcode::NegateStmt => {
                    self.is_stmt = !self.is_stmt;
                    // println!("is_stmt: {}", self.is_stmt);
                }
                Opcode::SetAddress(addr) => {
                    self.address = *addr;
                    self.op_index = 0;
                    // println!("addr: {:x}", self.address);
                }
                Opcode::SetBasicBlock => {
                    self.basic_block = true;
                    // println!("basic_block: {}", self.basic_block);
                }
                Opcode::SetColumn(column) => {
                    self.column = *column;
                    // println!("column: {}", self.column);
                }
                Opcode::SetEpilogueBegin => {
                    self.prologue_begin = true;
                    // println!();
                }
                Opcode::SetFile(file) => {
                    // I think this would be used for things like inline functions in an
                    // include for the compilation unit being compiled.
                    self.file = if (*file as usize) <= info.source_files.len() {
                        let sf = &info.source_files[*file as usize];
                        format!("{}/{}", sf.dir, sf.file)
                    } else {
                        format!("bad file index {file}")
                    };
                    // println!("file: {}", self.file);
                }
                Opcode::SetIsa(isa) => {
                    self.isa = *isa;
                    // println!();
                }
                Opcode::SetPrologueEnd => {
                    self.prologue_end = true;
                    // println!();
                }
                Opcode::SetDiscriminator(discriminator) => {
                    self.discriminator = *discriminator;
                    // println!();
                }
                Opcode::Special(adjust) => {
                    // 6.2.5.1
                    let advance = (adjust / info.line_range) as u32;
                    let addr_incr = (info.min_instruction_len as u32)
                        * ((self.op_index + advance) / (info.max_ops_per_instruction as u32));
                    self.address += addr_incr as u64;
                    self.op_index =
                        (self.op_index + advance) % (info.max_ops_per_instruction as u32);

                    let line_incr = (adjust % info.line_range) as i8 + info.line_base;
                    self.line = ((self.line as i64) + (line_incr as i64)) as u32;
                    self.record_line(files, lines);
                    // println!(
                    //     "{opcode:?} {:x} at {}:{}",
                    //     self.address, self.line, self.column
                    // );
                    self.basic_block = false;
                    self.prologue_end = false;
                    self.prologue_begin = false;
                    self.discriminator = 0;
                }
                Opcode::Vendor(_) => todo!(),
            }
        }
    }

    fn record_line(
        &self,
        files: &mut KeyMap<FilesKey, String>,
        lines: &mut Vec<(RelativeAddr, LineValue)>,
    ) {
        let file = files.insert(self.file.clone());
        let line_value = LineValue {
            file,
            line: self.line,
            column: self.column as u16,
        };
        lines.push((self.address, line_value));
    }
}

impl Opcode {
    fn from_steam(stream: &mut Stream, opcode_base: u8) -> Result<Self, Box<dyn Error>> {
        let code = stream.read_byte()?;
        let opcode = if code != 0 {
            // 6.2.5.2
            match code {
                1 => Opcode::Copy,
                2 => Opcode::AdvancePc(decode_u32(stream)?),
                3 => Opcode::AdvanceLine(decode_u32(stream)?),
                4 => Opcode::SetFile(decode_u32(stream)?),
                5 => Opcode::SetColumn(decode_u32(stream)?),
                6 => Opcode::NegateStmt,
                7 => Opcode::SetBasicBlock,
                8 => Opcode::ConstAddPc,
                9 => Opcode::FixedAdvancePc(stream.read_half()?),
                10 => Opcode::SetPrologueEnd,
                11 => Opcode::SetEpilogueBegin,
                12 => Opcode::SetIsa(decode_u32(stream)?),
                _ => {
                    if opcode_base < 13 {
                        Opcode::Special(code - opcode_base)
                    } else if opcode_base > 13 {
                        if code < opcode_base {
                            Opcode::Vendor(opcode_base - code)
                        } else {
                            Opcode::Special(code - opcode_base)
                        }
                    } else {
                        Opcode::Special(code - opcode_base)
                    }
                }
            }
        } else {
            // 6.2.5.3
            let _len = decode_u32(stream)?;
            let code = stream.read_byte()?;
            match code {
                1 => Opcode::EndSequence,
                2 => Opcode::SetAddress(RelativeAddr(stream.read_addr()?)),
                3 => Opcode::DefineFile(
                    stream.read_string()?,
                    decode_u32(stream)?,
                    decode_u32(stream)?,
                    decode_u32(stream)?,
                ),
                4 => Opcode::SetDiscriminator(decode_u32(stream)?),
                _ => return Err(format!("unknown extended opcode: {code}").into()),
            }
        };
        Ok(opcode)
    }
}

// #[derive(Clone, Copy, Debug, PartialEq, Eq)] // 6.2.4.1
// pub enum ContentType {
//     Path,
//     DirIndex,
//     Timestamp,
//     Size,
//     Md5Sum,
//     Vendor(u32),
// }

// #[derive(Clone, Copy, Debug, PartialEq, Eq)] // 7.5.6
// pub enum FormEncoding {
//     Addr,      // 0x01 address
//     Block2,    // 0x03 block
//     Block4,    // 0x04 block
//     Data2,     // 0x05 constant
//     Data4,     // 0x06 constant
//     Data8,     // 0x07 constant
//     String,    // 0x08 string
//     Block,     // 0x09 block
//     Block1,    // 0x0a block
//     Data1,     // 0x0b constant
//     Flag,      // 0x0c flag
//     Sdata,     // 0x0d constant
//     Strp,      // 0x0e string
//     Udata,     // 0x0f constant
//     RefAddr,   // 0x10 reference
//     Ref1,      // 0x11 reference
//     Ref2,      // 0x12 reference
//     Ref4,      // 0x13 reference
//     Ref8,      // 0x14 reference
//     RefUdata,  // 0x15 reference
//     Indirect,  // 0x16 (see Section 7.5.3 on page 203)
//     SecOffset, // 0x17 addrptr, lineptr, loclist, loclistsptr, macptr, rnglist, rnglistsptr, stroffsetsptr
//     Exprloc,   // 0x18 exprloc
//     FlagPresent, //0x19 flag
//                // Strx,      // 0x1a string (version 5)
//                // Addrx,     // 0x1b address (version 5)
//                // RefSup4,   // 0x1c reference (version 5)
//                // StrpSup,   // 0x1d string (version 5)
//                // Data16,    // 0x1e constant (version 5)
//                // LineStrp,  // 0x1f string (version 5)
//                // RefSig8,   // 0x20 reference (version 5)
//                // ImplicitConst, // 0x21 constant (version 5)
//                // Loclistx,  // 0x22 loclist (version 5)
//                // Rnglistx,  // 0x23 rnglist (version 5)
//                // RefSup8,   // 0x24 reference (version 5)
//                // Strx1,     // 0x25 string (version 5)
//                // Strx2,     // 0x26 string (version 5)
//                // Strx3,     // 0x27 string (version 5)
//                // Strx4,     // 0x28 string (version 5)
//                // Addrx1,    // 0x29 address (version 5)
//                // Addrx2,    // 0x2a address (version 5)
//                // Addrx3,    // 0x2b address (version 5)
//                // Addrx4,    // 0x2c address (version 5)
// }

// impl ContentType {
//     fn from_u32(value: u32) -> Self {
//         match value {
//             1 => ContentType::Path,
//             2 => ContentType::DirIndex,
//             3 => ContentType::Timestamp,
//             4 => ContentType::Size,
//             5 => ContentType::Md5Sum,
//             _ => ContentType::Vendor(value),
//         }
//     }
// }

// impl FormEncoding {
//     fn from_u32(value: u32) -> Result<Self, Box<dyn Error>> {
//         match value {
//             0x01 => Ok(FormEncoding::Addr),
//             0x03 => Ok(FormEncoding::Block2),
//             0x04 => Ok(FormEncoding::Block4),
//             0x05 => Ok(FormEncoding::Data2),
//             0x06 => Ok(FormEncoding::Data4),
//             0x07 => Ok(FormEncoding::Data8),
//             0x08 => Ok(FormEncoding::String),
//             0x09 => Ok(FormEncoding::Block),
//             0x0a => Ok(FormEncoding::Block1),
//             0x0b => Ok(FormEncoding::Data1),
//             0x0c => Ok(FormEncoding::Flag),
//             0x0d => Ok(FormEncoding::Sdata),
//             0x0e => Ok(FormEncoding::Strp),
//             0x0f => Ok(FormEncoding::Udata),
//             0x10 => Ok(FormEncoding::RefAddr),
//             0x11 => Ok(FormEncoding::Ref1),
//             0x12 => Ok(FormEncoding::Ref2),
//             0x13 => Ok(FormEncoding::Ref4),
//             0x14 => Ok(FormEncoding::Ref8),
//             0x15 => Ok(FormEncoding::RefUdata),
//             0x16 => Ok(FormEncoding::Indirect),
//             0x17 => Ok(FormEncoding::SecOffset),
//             0x18 => Ok(FormEncoding::Exprloc),
//             0x19 => Ok(FormEncoding::FlagPresent),
//             _ => Err(format!("unknown form encoding: {value}").into()),
//         }
//     }
// }

// section 7.6
/// LEB128 encoded
fn decode_u32(stream: &mut Stream) -> Result<u32, Box<dyn Error>> {
    let mut result = 0;
    let mut shift = 0;
    loop {
        let byte = stream.read_byte()? as u32;
        result |= (byte & 0x7F) << shift;
        if (byte & 0x80) == 0 {
            break;
        }
        shift += 7;
    }
    Ok(result)
}

// /// LEB128 encoded
// fn decode_u64(stream: &mut Stream) -> Result<u64, Box<dyn Error>> {
//     let mut result = 0;
//     let mut shift = 0;
//     loop {
//         let byte = stream.read_byte()? as u64;
//         result |= (byte & 0x7F) << shift;
//         if (byte & 0x80) == 0 {
//             break;
//         }
//         shift += 7;
//     }
//     Ok(result)
// }
